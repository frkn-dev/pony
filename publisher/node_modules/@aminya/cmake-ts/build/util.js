"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RUN = exports.EXEC = exports.EXEC_CAPTURE = exports.GET_CMAKE_VS_GENERATOR = void 0;
exports.stat = stat;
const child_process_1 = require("child_process");
const splitargs2_1 = __importDefault(require("splitargs2"));
const fs_extra_1 = require("fs-extra");
const GET_CMAKE_VS_GENERATOR = (cmake, arch) => __awaiter(void 0, void 0, void 0, function* () {
    const generators = yield (0, exports.EXEC_CAPTURE)(`"${cmake}" -G`);
    const hasCR = generators.includes('\r\n');
    const output = hasCR ? generators.split('\r\n') : generators.split('\n');
    let found = false;
    let useVSGen = "";
    for (const line of output) {
        if (!found && line.trim() === 'Generators') {
            found = true;
            continue;
        }
        const genParts = line.split('=');
        if (genParts.length <= 1) {
            continue;
        }
        genParts[0] = genParts[0].trim();
        if (genParts[0].match(/Visual\s+Studio\s+\d+\s+\d+\s+\[arch\]/)) {
            console.log('Found generator: ', genParts[0]);
            useVSGen = genParts[0];
            break;
        }
    }
    if (arch === 'x64') {
        useVSGen = useVSGen.replace('[arch]', 'Win64').trim();
    }
    else if (arch === 'x86') {
        useVSGen = useVSGen.replace('[arch]', '').trim();
    }
    else {
        console.error('Failed to find valid VS gen, using native. Good Luck.');
        return 'native';
    }
    return useVSGen;
});
exports.GET_CMAKE_VS_GENERATOR = GET_CMAKE_VS_GENERATOR;
const EXEC_CAPTURE = (command) => {
    return new Promise(resolve => {
        (0, child_process_1.exec)(command, (_, stdout, stderr) => {
            resolve(stdout || stderr);
        });
    });
};
exports.EXEC_CAPTURE = EXEC_CAPTURE;
const EXEC = (command) => {
    return new Promise((resolve, reject) => {
        (0, child_process_1.exec)(command, (err, stdout, stderr) => {
            if (err) {
                reject(new Error(`${err.message}\n${stdout || stderr}`));
            }
            else {
                resolve(stdout);
            }
        });
    });
};
exports.EXEC = EXEC;
const RUN = (command, cwd = process.cwd(), silent = false) => {
    return new Promise((resolve, reject) => {
        const args = (0, splitargs2_1.default)(command);
        const name = args[0];
        args.splice(0, 1);
        const child = (0, child_process_1.spawn)(name, args, {
            stdio: silent ? 'ignore' : 'inherit',
            cwd,
        });
        let ended = false;
        child.on('error', e => {
            if (!ended) {
                reject(e);
                ended = true;
            }
        });
        child.on('exit', (code, signal) => {
            if (ended) {
                return;
            }
            if (code === 0) {
                resolve();
            }
            else {
                reject(new Error(`Process terminated: ${code !== null && code !== void 0 ? code : signal}`));
            }
            ended = true;
        });
    });
};
exports.RUN = RUN;
function stat(path, options) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield (0, fs_extra_1.stat)(path, options);
        }
        catch (_a) {
            return new fs_extra_1.Stats();
        }
    });
}
//# sourceMappingURL=util.js.map