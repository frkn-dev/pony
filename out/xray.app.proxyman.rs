// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InboundConfig {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AllocationStrategy {
    #[prost(enumeration = "allocation_strategy::Type", tag = "1")]
    pub r#type: i32,
    /// Number of handlers (ports) running in parallel.
    /// Default value is 3 if unset.
    #[prost(message, optional, tag = "2")]
    pub concurrency: ::core::option::Option<
        allocation_strategy::AllocationStrategyConcurrency,
    >,
    /// Number of minutes before a handler is regenerated.
    /// Default value is 5 if unset.
    #[prost(message, optional, tag = "3")]
    pub refresh: ::core::option::Option<allocation_strategy::AllocationStrategyRefresh>,
}
/// Nested message and enum types in `AllocationStrategy`.
pub mod allocation_strategy {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AllocationStrategyConcurrency {
        #[prost(uint32, tag = "1")]
        pub value: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AllocationStrategyRefresh {
        #[prost(uint32, tag = "1")]
        pub value: u32,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Always allocate all connection handlers.
        Always = 0,
        /// Randomly allocate specific range of handlers.
        Random = 1,
        /// External. Not supported yet.
        External = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Always => "Always",
                Self::Random => "Random",
                Self::External => "External",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Always" => Some(Self::Always),
                "Random" => Some(Self::Random),
                "External" => Some(Self::External),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SniffingConfig {
    /// Whether or not to enable content sniffing on an inbound connection.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Override target destination if sniff'ed protocol is in the given list.
    /// Supported values are "http", "tls", "fakedns".
    #[prost(string, repeated, tag = "2")]
    pub destination_override: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub domains_excluded: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Whether should only try to sniff metadata without waiting for client input.
    /// Can be used to support SMTP like protocol where server send the first
    /// message.
    #[prost(bool, tag = "4")]
    pub metadata_only: bool,
    #[prost(bool, tag = "5")]
    pub route_only: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceiverConfig {
    /// PortList specifies the ports which the Receiver should listen on.
    #[prost(message, optional, tag = "1")]
    pub port_list: ::core::option::Option<super::super::common::net::PortList>,
    /// Listen specifies the IP address that the Receiver should listen on.
    #[prost(message, optional, tag = "2")]
    pub listen: ::core::option::Option<super::super::common::net::IpOrDomain>,
    #[prost(message, optional, tag = "3")]
    pub allocation_strategy: ::core::option::Option<AllocationStrategy>,
    #[prost(message, optional, tag = "4")]
    pub stream_settings: ::core::option::Option<
        super::super::transport::internet::StreamConfig,
    >,
    #[prost(bool, tag = "5")]
    pub receive_original_destination: bool,
    #[prost(message, optional, tag = "7")]
    pub sniffing_settings: ::core::option::Option<SniffingConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InboundHandlerConfig {
    #[prost(string, tag = "1")]
    pub tag: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub receiver_settings: ::core::option::Option<
        super::super::common::serial::TypedMessage,
    >,
    #[prost(message, optional, tag = "3")]
    pub proxy_settings: ::core::option::Option<
        super::super::common::serial::TypedMessage,
    >,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OutboundConfig {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SenderConfig {
    /// Send traffic through the given IP. Only IP is allowed.
    #[prost(message, optional, tag = "1")]
    pub via: ::core::option::Option<super::super::common::net::IpOrDomain>,
    #[prost(message, optional, tag = "2")]
    pub stream_settings: ::core::option::Option<
        super::super::transport::internet::StreamConfig,
    >,
    #[prost(message, optional, tag = "3")]
    pub proxy_settings: ::core::option::Option<
        super::super::transport::internet::ProxyConfig,
    >,
    #[prost(message, optional, tag = "4")]
    pub multiplex_settings: ::core::option::Option<MultiplexingConfig>,
    #[prost(string, tag = "5")]
    pub via_cidr: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiplexingConfig {
    /// Whether or not Mux is enabled.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Max number of concurrent connections that one Mux connection can handle.
    #[prost(int32, tag = "2")]
    pub concurrency: i32,
    /// Transport XUDP in another Mux.
    #[prost(int32, tag = "3")]
    pub xudp_concurrency: i32,
    /// "reject" (default), "allow" or "skip".
    #[prost(string, tag = "4")]
    pub xudp_proxy_udp443: ::prost::alloc::string::String,
}
