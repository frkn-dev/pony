"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultBuildConfiguration = defaultBuildConfiguration;
exports.defaultBuildOptions = defaultBuildOptions;
const which_1 = __importDefault(require("which"));
const util_1 = require("./util");
function defaultBuildConfiguration(config) {
    if (config.name === undefined) {
        config.name = '';
    }
    if (config.dev === undefined) {
        config.dev = false;
    }
    if (config.os === undefined) {
        config.os = process.platform;
        console.warn(`'os' was missing in the 'configurations'. Defaulting to the current operating system ${config.os}`);
    }
    if (config.arch === undefined) {
        config.arch = process.arch;
        console.warn(`'arch' was missing in the 'configurations'. Defaulting to the current architecture ${config.arch}`);
    }
    if (config.runtime === undefined) {
        config.runtime = "node";
        console.warn("`runtime` was missing in the `configurations`. Defaulting to `node`");
    }
    if (config.runtimeVersion === undefined) {
        config.runtimeVersion = process.versions.node;
        console.warn(`'runtimeVersion' was missing in the 'configurations'. Defaulting to the current runtimeVersion ${config.runtimeVersion}`);
    }
    if (config.toolchainFile === undefined) {
        config.toolchainFile = null;
    }
    if (config.CMakeOptions === undefined) {
        config.CMakeOptions = [];
    }
    if (config.cmakeOptions !== undefined) {
        console.warn('cmakeOptions was specified which was disabled in the 0.3.0 release. Please rename it to CMakeOptions');
    }
    if (config.addonSubdirectory === undefined) {
        config.addonSubdirectory = '';
    }
    config.additionalDefines = [];
    return config;
}
function whichWrapped(cmd) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield (0, which_1.default)(cmd);
        }
        catch (err) {
            return null;
        }
    });
}
function defaultBuildOptions(configs, buildmode) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (buildmode.type === 'nativeonly') {
            console.log(`--------------------------------------------------
      WARNING: Building only for the current runtime.
      WARNING: DO NOT SHIP THE RESULTING PACKAGE
     --------------------------------------------------`);
            configs.configurations = [defaultBuildConfiguration({})];
        }
        if (buildmode.type === 'osonly') {
            console.log(`--------------------------------------------------
      WARNING: Building only for the current OS.
      WARNING: DO NOT SHIP THE RESULTING PACKAGE
     --------------------------------------------------`);
            if (configs.configurations === undefined) {
                console.error('No `configurations` entry was found in the package.json');
                process.exit(1);
            }
            configs.configurations = configs.configurations.filter(j => j.os === process.platform);
            if (configs.configurations.length === 0) {
                console.error(`No configuration left to build!`);
                process.exit(1);
            }
            for (const config of configs.configurations) {
                config.toolchainFile = null;
            }
        }
        if (buildmode.type === 'dev-os-only') {
            console.log(`--------------------------------------------------
        WARNING: Building dev-os-only package
        WARNING: DO NOT SHIP THE RESULTING PACKAGE
       --------------------------------------------------`);
            if (configs.configurations === undefined) {
                console.error('No `configurations` entry was found in the package.json');
                process.exit(1);
            }
            const candidateConfig = configs.configurations.find(j => j.os === process.platform && j.dev);
            if (candidateConfig === undefined) {
                console.error(`No matching entry with \`dev == true\` and \`os == ${process.platform}\` in \`configurations\``);
                process.exit(1);
            }
            configs.configurations = [candidateConfig];
        }
        if (buildmode.type === 'named-configs') {
            if (configs.configurations === undefined) {
                console.error('No `configurations` entry was found in the package.json');
                process.exit(1);
            }
            configs.configurations = configs.configurations.filter(j => (j.name ? buildmode.configsToBuild.includes(j.name) : false));
            if (configs.configurations.length === 0) {
                console.error(`No configuration left to build!`);
                process.exit(1);
            }
        }
        if (configs.packageDirectory === undefined) {
            configs.packageDirectory = process.cwd();
        }
        if (configs.projectName === undefined) {
            configs.projectName = 'addon';
        }
        if (configs.targetDirectory === undefined) {
            configs.targetDirectory = 'build';
        }
        if (configs.stagingDirectory === undefined) {
            configs.stagingDirectory = 'staging';
        }
        if (configs.cmakeToUse === undefined) {
            const cmake = yield whichWrapped('cmake');
            if (!cmake) {
                console.error('cmake binary not found, try to specify \'cmakeToUse\'');
                process.exit(1);
            }
            configs.cmakeToUse = cmake;
        }
        const ninjaP = whichWrapped('ninja');
        const makeP = whichWrapped('make');
        let ninja;
        let make;
        if (configs.generatorToUse === undefined) {
            console.log('no generator specified, checking ninja');
            ninja = yield ninjaP;
            if (!ninja) {
                console.log('ninja not found, checking make');
                make = yield makeP;
                if (!make) {
                    console.log('make not found, using native');
                    if (process.platform === 'win32') {
                        const generator = yield (0, util_1.GET_CMAKE_VS_GENERATOR)(configs.cmakeToUse, process.arch);
                        configs.generatorToUse = generator;
                        configs.generatorBinary = 'native';
                    }
                    else {
                        configs.generatorToUse = 'native';
                        configs.generatorBinary = 'native';
                    }
                }
                else {
                    console.log('found make at', make, '(fallback)');
                    configs.generatorToUse = 'Unix Makefiles';
                    configs.generatorBinary = make;
                }
            }
            else {
                console.log('found ninja at', ninja);
                configs.generatorToUse = 'Ninja';
                configs.generatorBinary = ninja;
            }
        }
        if (configs.generatorBinary === undefined) {
            if (configs.generatorToUse === 'Ninja') {
                ninja = yield ninjaP;
                if (!ninja) {
                    console.error('Ninja was specified as generator but no ninja binary could be found. Specify it via \'generatorBinary\'');
                    process.exit(1);
                }
                configs.generatorBinary = ninja;
            }
            else if (configs.generatorToUse === 'Unix Makefiles') {
                make = yield makeP;
                if (!make) {
                    console.error('Unix Makefiles was specified as generator but no make binary could be found. Specify it via \'generatorBinary\'');
                    process.exit(1);
                }
                configs.generatorBinary = make;
            }
            else {
                console.error(`Unsupported generator ${configs.generatorToUse}`);
                process.exit(1);
            }
            ;
        }
        if (configs.buildType === undefined) {
            configs.buildType = "Release";
            console.warn("`buildType` was missing. Considering 'Release'");
        }
        (_a = configs.configurations) === null || _a === void 0 ? void 0 : _a.forEach(v => { v.additionalDefines = []; });
        return configs;
    });
}
//# sourceMappingURL=lib.js.map