// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransportConfig {
    /// Type of network that this settings supports.
    #[prost(string, tag = "3")]
    pub protocol_name: ::prost::alloc::string::String,
    /// Specific settings. Must be of the transports.
    #[prost(message, optional, tag = "2")]
    pub settings: ::core::option::Option<super::super::common::serial::TypedMessage>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamConfig {
    #[prost(message, optional, tag = "8")]
    pub address: ::core::option::Option<super::super::common::net::IpOrDomain>,
    #[prost(uint32, tag = "9")]
    pub port: u32,
    /// Effective network.
    #[prost(string, tag = "5")]
    pub protocol_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub transport_settings: ::prost::alloc::vec::Vec<TransportConfig>,
    /// Type of security. Must be a message name of the settings proto.
    #[prost(string, tag = "3")]
    pub security_type: ::prost::alloc::string::String,
    /// Settings for transport security. For now the only choice is TLS.
    #[prost(message, repeated, tag = "4")]
    pub security_settings: ::prost::alloc::vec::Vec<
        super::super::common::serial::TypedMessage,
    >,
    #[prost(message, optional, tag = "6")]
    pub socket_settings: ::core::option::Option<SocketConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProxyConfig {
    #[prost(string, tag = "1")]
    pub tag: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub transport_layer_proxy: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomSockopt {
    #[prost(string, tag = "1")]
    pub level: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub opt: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub value: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub r#type: ::prost::alloc::string::String,
}
/// SocketConfig is options to be applied on network sockets.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SocketConfig {
    /// Mark of the connection. If non-zero, the value will be set to SO_MARK.
    #[prost(int32, tag = "1")]
    pub mark: i32,
    /// TFO is the state of TFO settings.
    #[prost(int32, tag = "2")]
    pub tfo: i32,
    /// TProxy is for enabling TProxy socket option.
    #[prost(enumeration = "socket_config::TProxyMode", tag = "3")]
    pub tproxy: i32,
    /// ReceiveOriginalDestAddress is for enabling IP_RECVORIGDSTADDR socket
    /// option. This option is for UDP only.
    #[prost(bool, tag = "4")]
    pub receive_original_dest_address: bool,
    #[prost(bytes = "vec", tag = "5")]
    pub bind_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "6")]
    pub bind_port: u32,
    #[prost(bool, tag = "7")]
    pub accept_proxy_protocol: bool,
    #[prost(enumeration = "DomainStrategy", tag = "8")]
    pub domain_strategy: i32,
    #[prost(string, tag = "9")]
    pub dialer_proxy: ::prost::alloc::string::String,
    #[prost(int32, tag = "10")]
    pub tcp_keep_alive_interval: i32,
    #[prost(int32, tag = "11")]
    pub tcp_keep_alive_idle: i32,
    #[prost(string, tag = "12")]
    pub tcp_congestion: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub interface: ::prost::alloc::string::String,
    #[prost(bool, tag = "14")]
    pub v6only: bool,
    #[prost(int32, tag = "15")]
    pub tcp_window_clamp: i32,
    #[prost(int32, tag = "16")]
    pub tcp_user_timeout: i32,
    #[prost(int32, tag = "17")]
    pub tcp_max_seg: i32,
    #[prost(bool, tag = "18")]
    pub tcp_no_delay: bool,
    #[prost(bool, tag = "19")]
    pub tcp_mptcp: bool,
    #[prost(message, repeated, tag = "20")]
    pub custom_sockopt: ::prost::alloc::vec::Vec<CustomSockopt>,
}
/// Nested message and enum types in `SocketConfig`.
pub mod socket_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TProxyMode {
        /// TProxy is off.
        Off = 0,
        /// TProxy mode.
        TProxy = 1,
        /// Redirect mode.
        Redirect = 2,
    }
    impl TProxyMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Off => "Off",
                Self::TProxy => "TProxy",
                Self::Redirect => "Redirect",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Off" => Some(Self::Off),
                "TProxy" => Some(Self::TProxy),
                "Redirect" => Some(Self::Redirect),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DomainStrategy {
    AsIs = 0,
    UseIp = 1,
    UseIp4 = 2,
    UseIp6 = 3,
    UseIp46 = 4,
    UseIp64 = 5,
    ForceIp = 6,
    ForceIp4 = 7,
    ForceIp6 = 8,
    ForceIp46 = 9,
    ForceIp64 = 10,
}
impl DomainStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AsIs => "AS_IS",
            Self::UseIp => "USE_IP",
            Self::UseIp4 => "USE_IP4",
            Self::UseIp6 => "USE_IP6",
            Self::UseIp46 => "USE_IP46",
            Self::UseIp64 => "USE_IP64",
            Self::ForceIp => "FORCE_IP",
            Self::ForceIp4 => "FORCE_IP4",
            Self::ForceIp6 => "FORCE_IP6",
            Self::ForceIp46 => "FORCE_IP46",
            Self::ForceIp64 => "FORCE_IP64",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AS_IS" => Some(Self::AsIs),
            "USE_IP" => Some(Self::UseIp),
            "USE_IP4" => Some(Self::UseIp4),
            "USE_IP6" => Some(Self::UseIp6),
            "USE_IP46" => Some(Self::UseIp46),
            "USE_IP64" => Some(Self::UseIp64),
            "FORCE_IP" => Some(Self::ForceIp),
            "FORCE_IP4" => Some(Self::ForceIp4),
            "FORCE_IP6" => Some(Self::ForceIp6),
            "FORCE_IP46" => Some(Self::ForceIp46),
            "FORCE_IP64" => Some(Self::ForceIp64),
            _ => None,
        }
    }
}
