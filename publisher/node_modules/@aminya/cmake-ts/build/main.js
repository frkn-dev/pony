#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const lib_1 = require("./lib");
const path_1 = require("path");
const runtimeDistribution_1 = require("./runtimeDistribution");
const argumentBuilder_1 = require("./argumentBuilder");
const util_1 = require("./util");
const fs_extra_1 = require("fs-extra");
const override_1 = require("./override");
const buildMode_1 = require("./buildMode");
const DEBUG_LOG = Boolean(process.env.CMAKETSDEBUG);
(() => __awaiter(void 0, void 0, void 0, function* () {
    const argv = process.argv.slice(2);
    let packJson;
    try {
        packJson = require((0, path_1.resolve)((0, path_1.join)(process.cwd(), 'package.json')));
    }
    catch (err) {
        console.error('Failed to load package.json, maybe your cwd is wrong:', err);
        process.exit(1);
    }
    const configsGiven = packJson['cmake-ts'];
    if (configsGiven === undefined) {
        console.error('Package.json does not have cmake-ts key defined!');
        process.exit(1);
    }
    const buildMode = yield (0, buildMode_1.determineBuildMode)(argv);
    const configs = yield (0, lib_1.defaultBuildOptions)(configsGiven, buildMode);
    configs.targetDirectory = (0, path_1.resolve)((0, path_1.join)(configs.packageDirectory, configs.targetDirectory));
    configs.stagingDirectory = (0, path_1.resolve)((0, path_1.join)(configs.packageDirectory, configs.stagingDirectory));
    const stagingExists = yield (0, fs_extra_1.pathExists)(configs.stagingDirectory);
    console.log('running in', configs.packageDirectory, 'command', argv);
    process.stdout.write('> Setting up staging directory... ');
    if (stagingExists) {
        yield (0, fs_extra_1.remove)(configs.stagingDirectory);
        process.stdout.write('[ CLEARED ]');
    }
    yield (0, fs_extra_1.ensureDir)(configs.stagingDirectory);
    console.log('[ DONE ]');
    for (const configGiven of configs.configurations) {
        const config = (0, lib_1.defaultBuildConfiguration)(configGiven);
        const dist = new runtimeDistribution_1.RuntimeDistribution(config);
        console.log('---------------- BEGIN CONFIG ----------------');
        process.stdout.write('> Distribution File Download... ');
        yield dist.ensureDownloaded();
        console.log('[ DONE ]');
        process.stdout.write('> Determining ABI... ');
        yield dist.determineABI();
        console.log('[ DONE ]');
        process.stdout.write('> Building directories... ');
        const stagingDir = (0, path_1.resolve)((0, path_1.join)(configs.stagingDirectory, config.os, config.arch, config.runtime, `${dist.abi}`, config.addonSubdirectory));
        const targetDir = (0, path_1.resolve)((0, path_1.join)(configs.targetDirectory, config.os, config.arch, config.runtime, `${dist.abi}`, config.addonSubdirectory));
        console.log('[ DONE ]');
        process.stdout.write('> Applying overrides... ');
        const appliedOverrides = (0, override_1.applyOverrides)(config);
        console.log(`[ DONE, ${appliedOverrides} applied ]`);
        console.log('--------------- CONFIG SUMMARY ---------------');
        console.log('Name: ', config.name ? config.name : "N/A");
        console.log('OS/Arch:', config.os, config.arch);
        console.log('Runtime:', config.runtime, config.runtimeVersion);
        console.log('Target ABI:', dist.abi);
        console.log('Toolchain File:', config.toolchainFile);
        console.log('Custom CMake options:', (config.CMakeOptions && config.CMakeOptions.length > 0) ? 'yes' : 'no');
        console.log('Staging area:', stagingDir);
        console.log('Target directory:', targetDir);
        console.log('Build Type', configs.buildType);
        console.log('----------------------------------------------');
        process.stdout.write('> Setting up config specific staging directory... ');
        yield (0, fs_extra_1.ensureDir)(stagingDir);
        console.log('[ DONE ]');
        const argBuilder = new argumentBuilder_1.ArgumentBuilder(config, configs, dist);
        process.stdout.write('> Building CMake command line... ');
        const cmdline = yield argBuilder.buildCmakeCommandLine();
        const buildcmdline = argBuilder.buildGeneratorCommandLine(stagingDir);
        console.log('[ DONE ]');
        if (DEBUG_LOG) {
            console.log('====> configure: ', cmdline);
            console.log('====> build:     ', buildcmdline);
        }
        process.stdout.write('> Invoking CMake... ');
        yield (0, util_1.RUN)(cmdline, stagingDir, false);
        console.log('[ DONE ]');
        process.stdout.write(`> Invoking ${configs.generatorBinary}... `);
        yield (0, util_1.RUN)(buildcmdline, stagingDir, false);
        console.log('[ DONE ]');
        process.stdout.write(`> Copying ${configs.projectName}.node to target directory... `);
        yield (0, fs_extra_1.ensureDir)(targetDir);
        if (configs.generatorToUse.includes('Visual Studio')) {
            if (DEBUG_LOG) {
                console.log(`Applying copy fix for MSVC projects`);
            }
            yield (0, fs_extra_1.copy)((0, path_1.join)(stagingDir, configs.buildType, `${configs.projectName}.node`), (0, path_1.join)(targetDir, `${configs.projectName}.node`));
        }
        else {
            yield (0, fs_extra_1.copy)((0, path_1.join)(stagingDir, `${configs.projectName}.node`), (0, path_1.join)(targetDir, `${configs.projectName}.node`));
        }
        console.log('[ DONE ]');
        console.log('----------------- END CONFIG -----------------');
    }
}))().catch((err) => {
    console.log("Generic error occured", err);
    process.exit(1);
});
//# sourceMappingURL=main.js.map